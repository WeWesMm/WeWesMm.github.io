---
title: 运行时区域数据
date: 2021-09-13 22:38:19
categories: JVM
tags:
 - Java
 - JVM
---

&emsp;&emsp;Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。根据《Java 虚拟机规范》的规定，Java 虚拟机所管理的将会包括一下几个运行时数据区域。

![](/images/jvm/chapter1/1625581892115-91d7bf9d-9d6f-4ae4-a730-743434dadfa6.png)

## 程序计数器

&emsp;&emsp;程序计数器（Program Counter Register）是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。在 Java 虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，<span style="color:red">它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</span>

&emsp;&emsp;由于 Java 虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

&emsp;&emsp;<span style="color:red">此内存区域是唯一一个在《Java 虚拟机规范》中没有规定任何 OOM 情况的区域。</span>

## Java 虚拟机栈

&emsp;&emsp;Java 虚拟机栈（Java Virtual Machine Stack）也是线程私有的，即<span style="color:red">每个线程都有一个独立的 Java 虚拟机栈</span>，它的生命周期与线程同步。虚拟机栈描述的是 Java 方法执行的线程内存模型：<span style="color:red">每个方法被执行的时候，Java 虚拟机栈都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。</span>每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

&emsp;&emsp;局部变量表存放了编译期可知的各种 Java 基本数据类型（boolean、byte、char、short、int、long、float、double）、对象引用（reference 类型，它并不等同于对象本身，可能只是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和 returnArddress 类型（指向一条字节码指令的地址）。

&emsp;&emsp;这些数据类型在局部变量表中的存储空间以<span style="color:red">局部变量槽（Slot）</span>来表示，其中 64 位的 long 和 double 占用两个变量槽，其余的数据只占用一个。<span style="color:red">局部变量表所需要的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</span>注意，这里说的“大小”指定是变量槽的数量，虚拟机真正使用多大的内存空间来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情。

&emsp;&emsp;在《Java 虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果 Java 虚拟机栈容量可以动态扩展，当栈扩展式无法申请到足够的内存就会抛出 OOM 异常。

> &emsp;&emsp;HotSpot 虚拟机的栈容量是不可以动态扩展的，以前的 Classic 虚拟机倒是可以。因此在 HotSpot 虚拟机上是不会由于虚拟机栈无法扩展而导致 OOM 异常——只要线程申请栈空间成功了就不会有 OOM，但是如果申请时就失败，仍然会出现 OOM 异常。
>

## 本地方法栈

&emsp;&emsp;本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。

&emsp;&emsp;与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出 StackOverflowError 和 OOM 异常。

## Java 堆

&emsp;&emsp;对于 Java 应用来说，Java 堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块区域，在虚拟机启动时创建。<span style="color:red">此内存区域的唯一目的就是存放对象实例，Java 世界里“几乎”所有的对象实例都在这里分配内存。</span>

&emsp;&emsp;Java 堆是垃圾收集器管理的内存区域，因此一些资料中把它称之为“GC堆”（Garbage Collected Heap）。

&emsp;&emsp;从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所有 Java 堆中经常会出现“新生代”“老年代”“永久代”“Eden 空间”“From Survivor 空间”“To Survivor空间”等名词，这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已，而非某个 Java 虚拟机具体实现的固有的内存布局，更不是《Java 虚拟机规范》里对 Java 堆的进一步细致划分。

&emsp;&emsp;从分配内存的角度看，所有线程共享的 Java 堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。

&emsp;&emsp;根据《Java 虚拟机规范》的规定，Java 堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于大对象（如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的存储空间。

## 方法区

&emsp;&emsp;方法区（Method Area）与 Java 堆一样，是各个线程共享的区域，它<span style="color:red">用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。虽然《Java 虚拟机规范》中把方法区描述为堆的一个逻辑部分</span>，但是它却有一个别名叫做“非堆”（Non-Heap），目的是与 Java 堆区分开来。

&emsp;&emsp;说到方法区，不得不提下“永久代”这个概念，在 JDK 8 以前，很多人都更愿意把方法区称为“永久代”（Permanent Generation），或将两者混为一谈。本质上这两者并不是等价的，因为仅仅是当时的 HotSpot 虚拟机设计团队选择将收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得 HotSpot 的垃圾收集器能够想管理 Java 堆一样管理这个内存区域，省去专门为方法区编写内存管理代码的工作。但是对于其他虚拟机实现，譬如 BEA JRockit、IBM J9 等来说，是不存在永久代的概念的。在 JDK 6 的时候 HotSpot 团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划了，到了<span style="color:red"> JDK 7 的 HotSpot，已经把原来放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，终于完全废弃了永久代的概念，改用在本地内存中实现的元空间（Meta space）来代替，把 JDK 7 中永久代还剩余的内容（主要是类型信息）全部移到元空间中。</span>

&emsp;&emsp;相对 Java 堆而言，垃圾收集行为在这个区域的确比较少出现，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和卸载，条件相当苛刻，但是这部分区域的回收有时有时必要的。

&emsp;&emsp;如果方法区无法满足新的内存分配需求时，将抛出 OOM 异常。

## 运行时常量池

&emsp;&emsp;运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是<span style="color:red">常量池表（Constant Pool Table），用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</span>

&emsp;&emsp;运行时常量池相对于 Class 文件常量池的另外一个重要特征是具备动态性，Java 语言不要求常量一定只有编译期才能产生，也就是说，并非预置入 Class 文件中的常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是 `String#intern()` 方法。

&emsp;&emsp;既然运行时常量池是方法区的一部分，自然受到方法区的限制，当常量池无法再申请到内存时会抛出 OOM 异常。

## 直接内存

&emsp;&emsp;直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java 虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OOM 异常出现。

&emsp;&emsp;在 JDK 1.4 中新加入了 NIO 类，引入了一种基于通道（Channel）和缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后直接通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。

&emsp;&emsp;直接内存的分配不会受到 Java 堆大小的限制，但是，会受到本机总内存（包括物理内存、SWAP 分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置 -Xmx 等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制，从而导致了 OOM 异常。